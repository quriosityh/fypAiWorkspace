/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ReadingViewEnhancer
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// src/constants.ts
var MARKDOWN_PREVIEW_VIEW = "markdown-preview-view";
var FRONTMATTER = "frontmatter";
var BLOCKS = [
  "p",
  "li",
  "table",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "pre",
  "blockquote",
  "img",
  "video",
  "audio",
  "iframe",
  "[data-callout]"
];
var BLOCK_SELECTOR = "rve-block-selector";
var BLOCK_ATTR = "data-rve-block";
var SELECTED_BLOCK = "rve-selected-block";
var COLLAPSE_INDICATORS = [".collapse-indicator", ".callout-fold"];
var IS_COLLAPSED = "is-collapsed";

// src/styles.ts
var StyleRule = class {
  constructor(template, injectVariables) {
    this.template = template;
    this.isActive = false;
    this.injectVariables = injectVariables;
  }
  /**
   * Get the rule after injecting variables
   *
   * @returns {string} The rule
   */
  getRule() {
    return this.injectVariables(this.template);
  }
};
var BlockColorRule = class extends StyleRule {
  constructor() {
    const template = `
			.${SELECTED_BLOCK} {
				position: relative;
			}
			
			.${SELECTED_BLOCK}::before {
				content: "";
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				pointer-events: none;
				background-color: {{BLOCK_COLOR}}1a;
			}
		`;
    super(template, (template2) => {
      return template2.replace("{{BLOCK_COLOR}}", this.blockColor);
    });
    this.isActive = true;
  }
  /**
   * Set the block color
   *
   * @param blockColor {string} The block color
   */
  set(blockColor) {
    this.blockColor = blockColor;
  }
};
var CollapseIndicatorRule = class extends StyleRule {
  constructor() {
    const template = `
			.markdown-preview-section .collapse-indicator {
				opacity: 1;
			}
		`;
    super(template, (template2) => template2);
  }
};
var PreventTableOverflowingRule = class extends StyleRule {
  constructor() {
    const template = `
			.markdown-preview-section > div:has(table) {
				overflow: auto;
			}

			.markdown-preview-section thead > tr > th,
			.markdown-preview-section tbody > tr > td {
				white-space: nowrap;
			}
		`;
    super(template, (template2) => template2);
  }
};
var ScrollableCodeRule = class extends StyleRule {
  constructor() {
    const template = `
			.markdown-preview-section div > pre {
				overflow: hidden;
				white-space: pre-wrap;
			}

			.markdown-preview-section div > pre > code {
				display: block;
				overflow: auto;
				white-space: pre;
			}
		`;
    super(template, (template2) => template2);
  }
};
var RveStyles = class {
  constructor() {
    this.styleTag = document.createElement("style");
    this.styleTag.id = "rve-styles";
    document.getElementsByTagName("head")[0].appendChild(this.styleTag);
    this.rules = {
      "block-color": new BlockColorRule(),
      "collapse-indicator": new CollapseIndicatorRule(),
      "prevent-table-overflowing": new PreventTableOverflowingRule(),
      "scrollable-code": new ScrollableCodeRule()
    };
  }
  /**
   * Clean up the style tag
   */
  cleanup() {
    this.styleTag.remove();
  }
  /**
   * Get a rule by key
   *
   * @param rule {RuleKey} rule's key
   * @returns {StyleRule} One of the rules
   */
  of(rule) {
    return this.rules[rule];
  }
  /**
   * Apply all active rules
   */
  apply() {
    const style = Object.values(this.rules).filter((rule) => rule.isActive).map((rule) => rule.getRule()).join("\n");
    this.styleTag.innerHTML = style;
  }
};

// src/settings/index.ts
var import_obsidian7 = require("obsidian");

// node_modules/color2k/dist/index.exports.import.es.mjs
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
var ColorError = class extends Error {
  constructor(color) {
    super(`Failed to parse color: "${color}"`);
  }
};
var ColorError$1 = ColorError;
function parseToRgba(color) {
  if (typeof color !== "string")
    throw new ColorError$1(color);
  if (color.trim().toLowerCase() === "transparent")
    return [0, 0, 0, 0];
  let normalizedColor = color.trim();
  normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || "f", 2), 16) / 255];
  }
  const hexMatch = hexRegex.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 16)), parseInt(arr[3] || "ff", 16) / 255];
  }
  const rgbaMatch = rgbaRegex.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 10)), parseFloat(arr[3] || "1")];
  }
  const hslaMatch = hslaRegex.exec(normalizedColor);
  if (hslaMatch) {
    const [h, s, l, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s) !== s)
      throw new ColorError$1(color);
    if (guard(0, 100, l) !== l)
      throw new ColorError$1(color);
    return [...hslToRgb(h, s, l), Number.isNaN(a) ? 1 : a];
  }
  throw new ColorError$1(color);
}
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i) {
    hash2 = hash2 * 33 ^ str.charCodeAt(--i);
  }
  return (hash2 >>> 0) % 2341;
}
var colorToInt = (x) => parseInt(x.replace(/_/g, ""), 36);
var compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next) => {
  const key = colorToInt(next.substring(0, 3));
  const hex = colorToInt(next.substring(3)).toString(16);
  let prefix = "";
  for (let i = 0; i < 6 - hex.length; i++) {
    prefix += "0";
  }
  acc[key] = `${prefix}${hex}`;
  return acc;
}, {});
function nameToHex(color) {
  const normalizedColorName = color.toLowerCase().trim();
  const result = compressedColorMap[hash(normalizedColorName)];
  if (!result)
    throw new ColorError$1(color);
  return `#${result}`;
}
var r = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
var reducedHexRegex = new RegExp(`^#${r("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
var hexRegex = new RegExp(`^#${r("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
var rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
var hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
var namedColorRegex = /^[a-z]+$/i;
var roundColor = (color) => {
  return Math.round(color * 255);
};
var hslToRgb = (hue, saturation, lightness) => {
  let l = lightness / 100;
  if (saturation === 0) {
    return [l, l, l].map(roundColor);
  }
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  const lightnessModification = l - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};
function toHex(color) {
  const [r2, g, b, a] = parseToRgba(color);
  let hex = (x) => {
    const h = guard(0, 255, x).toString(16);
    return h.length === 1 ? `0${h}` : h;
  };
  return `#${hex(r2)}${hex(g)}${hex(b)}${a < 1 ? hex(Math.round(a * 255)) : ""}`;
}

// src/settings/block/block-color.ts
var import_obsidian = require("obsidian");
var BlockColorSetting = class extends import_obsidian.Setting {
  constructor(settingsTabEl, plugin) {
    super(settingsTabEl);
    this.plugin = plugin;
    this.setName("Block Color").setDesc(
      "Set background color of the block in reading view. Transparency will be set automatically"
    ).addColorPicker((color) => this.colorPicker(color));
  }
  /**
   * Creates color picker component.
   * Also, creates a button to set color to the current accent color.
   *
   * @param color {ColorComponent} Color component
   */
  colorPicker(color) {
    const { settings } = this.plugin;
    color.setValue(settings.blockColor).onChange((changed) => {
      settings.blockColor = toHex(changed);
      this.plugin.saveSettings();
      this.plugin.applyBlockColor(true);
    });
    this.addButton((button) => this.accentColorButton(button, color));
  }
  /**
   * Creates a button to use current accent color.
   * Used in {@link colorPicker}.
   *
   * @param button {ButtonComponent} Button component
   * @param color {ColorComponent} Color component
   */
  accentColorButton(button, color) {
    button.setButtonText("Use current accent color").onClick(() => {
      const accentColor = this.getAccentColor();
      color.setValue(accentColor);
      this.plugin.settings.blockColor = accentColor;
      this.plugin.saveSettings();
      this.plugin.applyBlockColor(true);
    });
  }
  /**
   * Gets current accent color from Obsidian.
   *
   * @returns Current accent color in hex format
   */
  getAccentColor() {
    const workspaceEl = this.plugin.app.workspace.containerEl;
    const accentColor = toHex(
      getComputedStyle(workspaceEl).getPropertyValue("--color-accent").trim()
    );
    return accentColor;
  }
};

// src/settings/block/block-selector.ts
var import_obsidian2 = require("obsidian");
var EnableBlockSelectorSetting = class extends import_obsidian2.Setting {
  constructor(containerEl, plugin) {
    super(containerEl);
    this.plugin = plugin;
    this.setName("Enable Block Selector").setDesc(
      "To take effect of changing this setting, you can either reopen (close & open) reading views or restart Obsidian. Alternatively, you can run the \u2018Rerender all reading views\u2019 command. Please note that when you rerender reading views, the file title will disappear."
    ).addToggle((toggle) => this.setEnableSelector(toggle));
  }
  /**
   * Creates toggle component that enables/disables block selector.
   *
   * @param toggle {ToggleComponent} Toggle component
   */
  setEnableSelector(toggle) {
    toggle.setValue(this.plugin.settings.enableBlockSelector);
    toggle.onChange((changed) => {
      this.plugin.settings.enableBlockSelector = changed;
      this.plugin.saveSettings();
    });
  }
};

// src/settings/block/block-selector-mobile.ts
var import_obsidian3 = require("obsidian");
var DisableBlockSelectorOnMobileSetting = class extends import_obsidian3.Setting {
  constructor(containerEl, plugin) {
    super(containerEl);
    this.plugin = plugin;
    this.setName("Disable Block Selector on Mobile").setDesc(
      "To take effect of changing this setting, you can either reopen (close & open) reading views or restart Obsidian. Alternatively, you can run the \u2018Rerender all reading views\u2019 command. Please note that when you rerender reading views, the file title will disappear."
    ).addToggle((toggle) => this.setDisableSelectorOnMobile(toggle));
  }
  /**
   * Creates toggle component that enables/disables block selector on mobile.
   *
   * @param toggle {ToggleComponent} Toggle component
   */
  setDisableSelectorOnMobile(toggle) {
    toggle.setValue(this.plugin.settings.disableBlockSelectorOnMobile);
    toggle.onChange((changed) => {
      this.plugin.settings.disableBlockSelectorOnMobile = changed;
      this.plugin.saveSettings();
    });
  }
};

// src/settings/block/index.ts
var BlockSelectorSettings = class {
  constructor(containerEl, plugin) {
    containerEl.createEl("h2", { text: "Block Selector" });
    new BlockColorSetting(containerEl, plugin);
    new EnableBlockSelectorSetting(containerEl, plugin);
    new DisableBlockSelectorOnMobileSetting(containerEl, plugin);
  }
};

// src/settings/miscellaneous/always-on-collapse-indicator.ts
var import_obsidian4 = require("obsidian");
var AlwaysOnCollapseIndicatorSetting = class extends import_obsidian4.Setting {
  constructor(settingsTabEl, plugin) {
    super(settingsTabEl);
    this.plugin = plugin;
    this.setName("Always on collapse indicator").setDesc("Set collapse indicators always visible in reading view.").addToggle((toggle) => this.alwaysOnCollapseIndicator(toggle));
  }
  /**
   * Creates toggle component
   *
   * @param toggle {ToggleComponent} Toggle component
   */
  alwaysOnCollapseIndicator(toggle) {
    const { settings } = this.plugin;
    toggle.setValue(settings.alwaysOnCollapseIndicator).onChange((changed) => {
      settings.alwaysOnCollapseIndicator = changed;
      this.plugin.saveSettings();
      this.plugin.applyAlwaysOnCollapse(true);
    });
  }
};

// src/settings/miscellaneous/prevent-table-overflow.ts
var import_obsidian5 = require("obsidian");
var PreventTableOverflowingSetting = class extends import_obsidian5.Setting {
  constructor(containerEl, plugin) {
    super(containerEl);
    this.plugin = plugin;
    this.setName("Prevent Table Overflowing").setDesc(
      "Make tables scrollable to prevent table overflowing. In Obsidian v1.1.16, table with a long text makes a horizontal scroll bar on the whole view. This setting prevents that."
    ).addToggle((toggle) => this.preventTableOverflowing(toggle));
  }
  preventTableOverflowing(toggle) {
    toggle.setValue(this.plugin.settings.preventTableOverflowing);
    toggle.onChange((changed) => {
      this.plugin.settings.preventTableOverflowing = changed;
      this.plugin.saveSettings();
      this.plugin.applyPreventTableOverflowing(true);
    });
  }
};

// src/settings/miscellaneous/scrollable-code.ts
var import_obsidian6 = require("obsidian");
var ScrollableCodeSetting = class extends import_obsidian6.Setting {
  constructor(containerEl, plugin) {
    super(containerEl);
    this.plugin = plugin;
    this.setName("Scrollable Code").setDesc("Make code blocks scrollable instead of line break.").addToggle((toggle) => this.setCodeScrollable(toggle));
  }
  setCodeScrollable(toggle) {
    toggle.setValue(this.plugin.settings.scrollableCode);
    toggle.onChange((changed) => {
      this.plugin.settings.scrollableCode = changed;
      this.plugin.saveSettings();
      this.plugin.applyScrollableCode(true);
    });
  }
};

// src/settings/miscellaneous/index.ts
var MiscellaneousSettings = class {
  constructor(containerEl, plugin) {
    containerEl.createEl("h2", { text: "Miscellaneous" });
    new AlwaysOnCollapseIndicatorSetting(containerEl, plugin);
    new PreventTableOverflowingSetting(containerEl, plugin);
    new ScrollableCodeSetting(containerEl, plugin);
  }
};

// src/settings/index.ts
var DEFAULT_SETTINGS = {
  blockColor: "#8b6cef",
  // Obsidian default color
  enableBlockSelector: false,
  disableBlockSelectorOnMobile: false,
  alwaysOnCollapseIndicator: false,
  preventTableOverflowing: false,
  scrollableCode: false
};
var RveSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  /**
   * Displays settings tab.
   */
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Reading View Enhancer" });
    new BlockSelectorSettings(containerEl, this.plugin);
    new MiscellaneousSettings(containerEl, this.plugin);
  }
};

// src/commands/commands.ts
var commands_exports = {};
__export(commands_exports, {
  rerenderAllReadingViews: () => rerenderAllReadingViews,
  selectTopBlockInTheView: () => selectTopBlockInTheView
});
var import_obsidian8 = require("obsidian");
var rerenderAllReadingViews = (plugin) => ({
  id: "rerender-all-reading-views",
  name: "Rerender all reading views",
  callback: () => {
    const { workspace } = plugin.app;
    workspace.getLeavesOfType("markdown").forEach((leaf) => {
      var _a;
      if (leaf.view.getState().mode === "preview") {
        (_a = leaf.view.previewMode) == null ? void 0 : _a.rerender(true);
      }
    });
  }
});
var selectTopBlockInTheView = (plugin) => ({
  id: "select-top-block-in-the-view",
  name: "Select Top Block in the View",
  checkCallback: (checking) => {
    if (checking) {
      if (isNotReadingView(plugin))
        return false;
      else if (isNotEnabled(plugin))
        return false;
      else if (isMobileAndDisabled(plugin))
        return false;
      else
        return true;
    } else {
      const container = getReadingViewContainer(plugin);
      if (container) {
        plugin.blockSelector.selectTopBlockInTheView(container);
      }
      return true;
    }
  }
});
var isNotReadingView = (plugin) => {
  const activeView = getActiveView(plugin);
  return (activeView == null ? void 0 : activeView.getState().mode) !== "preview";
};
var isNotEnabled = (plugin) => {
  return !plugin.settings.enableBlockSelector;
};
var isMobileAndDisabled = (plugin) => {
  return (import_obsidian8.Platform.isMobile || import_obsidian8.Platform.isMobileApp) && plugin.settings.disableBlockSelectorOnMobile;
};
var getReadingViewContainer = (plugin) => {
  const activeView = getActiveView(plugin);
  return activeView == null ? void 0 : activeView.previewMode.containerEl;
};
var getActiveView = (plugin) => {
  const { workspace } = plugin.app;
  return workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
};

// src/commands/index.ts
var Commands = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  register() {
    Object.values(commands_exports).map((revCommand) => revCommand(this.plugin)).forEach((command) => this.plugin.addCommand(command));
  }
};

// src/block-selector/index.ts
var import_obsidian9 = require("obsidian");

// src/block-selector/selection-util.ts
var isBottomInView = (block) => {
  const rect = block.getBoundingClientRect();
  return rect.bottom <= window.innerHeight;
};
var scrollBottomIntoView = (block) => {
  const rect = block.getBoundingClientRect();
  const scrollable = getScrollParent(block);
  scrollable == null ? void 0 : scrollable.scrollBy({
    behavior: "auto",
    top: rect.bottom - scrollable.clientHeight + 200
  });
};
var isTopInView = (block) => {
  const rect = block.getBoundingClientRect();
  return rect.top >= 0;
};
var scrollTopIntoView = (block) => {
  const rect = block.getBoundingClientRect();
  const scrollable = getScrollParent(block);
  scrollable == null ? void 0 : scrollable.scrollBy({
    behavior: "auto",
    top: rect.top - 200
  });
};
var findNextBlock = (currentElement) => {
  let nextBlock = null;
  if (!isCollapsed(currentElement)) {
    const children = currentElement.children;
    for (let i = 0; i < children.length; i++) {
      nextBlock = findBlock(children[i]);
      if (nextBlock)
        return nextBlock;
    }
  }
  let nextSibling = currentElement.nextElementSibling;
  while (nextSibling) {
    nextBlock = findBlock(nextSibling);
    if (nextBlock)
      return nextBlock;
    nextSibling = nextSibling.nextElementSibling;
  }
  let parent = currentElement.parentElement;
  while (parent && !parent.hasClass(MARKDOWN_PREVIEW_VIEW)) {
    let parentSibling = parent.nextElementSibling;
    while (parentSibling) {
      nextBlock = findBlock(parentSibling);
      if (nextBlock)
        return nextBlock;
      parentSibling = parentSibling.nextElementSibling;
    }
    parent = parent.parentElement;
  }
  return null;
};
var findPreviousBlock = (currentElement) => {
  let prevSibling = currentElement.previousElementSibling;
  while (prevSibling) {
    const prevBlock = findLastBlock(prevSibling);
    if (prevBlock)
      return prevBlock;
    prevSibling = prevSibling.previousElementSibling;
  }
  let parent = currentElement.parentElement;
  while (parent && !parent.classList.contains(MARKDOWN_PREVIEW_VIEW)) {
    if (isBlock(parent))
      return parent;
    let parentSibling = parent.previousElementSibling;
    while (parentSibling) {
      const prevBlock = findLastBlock(parentSibling);
      if (prevBlock)
        return prevBlock;
      parentSibling = parentSibling.previousElementSibling;
    }
    parent = parent.parentElement;
  }
  return null;
};
var isCollapsed = (element) => {
  return element.hasClass(IS_COLLAPSED);
};
var findBlock = (element) => {
  if (isBlock(element)) {
    return element;
  }
  let block = null;
  const childElements = element.children;
  for (let i = 0; i < childElements.length; i++) {
    block = findBlock(childElements[i]);
    if (block)
      return block;
  }
  return null;
};
var findLastBlock = (element) => {
  if (isCollapsed(element) && isBlock(element))
    return element;
  let block = null;
  const childElements = element.children;
  for (let i = childElements.length - 1; i >= 0; i--) {
    block = findLastBlock(childElements[i]);
    if (block)
      return block;
  }
  if (isBlock(element))
    return element;
  else
    return null;
};
var isBlock = (element) => {
  return element.getAttribute(BLOCK_ATTR) === "true";
};
var getScrollParent = (node) => {
  if (node == null)
    return null;
  if (node.scrollHeight > node.clientHeight) {
    return node;
  } else {
    return getScrollParent(node.parentNode);
  }
};

// src/block-selector/selection-handler.ts
var SelectionHandler = class {
  constructor() {
    this.selectedBlock = null;
  }
  /**
   * Select block element
   *
   * @param block {HTMLElement} Block element
   */
  select(block) {
    block.focus();
    block.addClass(SELECTED_BLOCK);
    this.selectedBlock = block;
  }
  /**
   * Unselect block element.
   * If there is no selected block, do nothing.
   *
   * @param block {HTMLElement} Block element
   */
  unselect() {
    if (this.selectedBlock) {
      this.selectedBlock.removeClass(SELECTED_BLOCK);
      this.selectedBlock.blur();
      this.selectedBlock = null;
    }
  }
  /**
   * Trigger 'select' on clicked block element.
   *
   * @param e {MouseEvent} Mouse event
   */
  onBlockClick(e) {
    const target = e.target;
    const block = target.closest(`[${BLOCK_ATTR}=true]`);
    if (block instanceof HTMLElement) {
      this.select(block);
    }
  }
  /**
   * On keydown, navigate between blocks or fold/unfold blocks.
   *
   * - `ArrowDown`: Select next block
   * - `ArrowUp`: Select previous block
   * - `ArrowLeft` & `ArrowRight`: Fold/Unfold block
   *
   * If selected block is too long,
   * `ArrowDown` and `ArrowUp` scrolls to see the element's bottom or top.
   * This is for loading adjacent blocks which are not in the DOM tree.
   *
   * @param e {KeyboardEvent} Keyboard event
   * @param scrollable {HTMLElement} Scrollable parent element
   */
  onKeyDown(e) {
    const block = e.target;
    if (e.key === "ArrowDown") {
      e.preventDefault();
      this.selectNextBlockOrScroll(block);
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      this.selectPreviousBlockOrScroll(block);
    } else if (e.key === "ArrowRight" || e.key === "ArrowLeft") {
      e.preventDefault();
      this.toggleFold(block);
    } else if (e.key === "Escape") {
      this.unselect();
    }
  }
  /**
   * Select next block or scroll to see the block's bottom.
   *
   * @param block {HTMLElement} Block element
   */
  selectNextBlockOrScroll(block) {
    if (!isBottomInView(block)) {
      scrollBottomIntoView(block);
    } else {
      const next = findNextBlock(block);
      if (next)
        this.select(next);
    }
  }
  /**
   * Select previous block or scroll to see the block's top.
   *
   * @param block {HTMLElement} Block element
   */
  selectPreviousBlockOrScroll(block) {
    if (!isTopInView(block)) {
      scrollTopIntoView(block);
    } else {
      const prev = findPreviousBlock(block);
      if (prev)
        this.select(prev);
    }
  }
  /**
   * Select top block in the view
   *
   * @param viewContainer {HTMLElement} View container element
   */
  selectTopBlockInTheView(viewContainer) {
    const blocks = viewContainer.querySelectorAll(`[${BLOCK_ATTR}=true]`);
    if (blocks.length === 0)
      return;
    let topIndex = -1;
    for (let i = 0; i < blocks.length; i++) {
      topIndex = i;
      const rect = blocks[i].getBoundingClientRect();
      if (rect.bottom > 120) {
        break;
      }
    }
    const topBlock = blocks[topIndex];
    this.select(topBlock);
  }
  /**
   * Fold/Unfold block.
   *
   * @param block {HTMLElement} Block element
   */
  toggleFold(block) {
    const collapseIndicator = block.querySelector(
      COLLAPSE_INDICATORS.join(",")
    );
    if (collapseIndicator) {
      collapseIndicator.click();
    }
  }
};

// src/block-selector/index.ts
var BlockSelector = class {
  /**
   * Initialize BlockSelector.
   * Register markdown post processor to blockify some elements.
   *
   * @param plugin {ReadingViewEnhancer} Plugin instance
   */
  constructor(plugin) {
    this.plugin = plugin;
    this.selectionHandler = new SelectionHandler();
  }
  /**
   * Activate BlockSelector
   */
  activate() {
    this.plugin.registerMarkdownPostProcessor(this.blockify.bind(this));
  }
  /**
   * Select top block in the view
   *
   * @param viewContainer {HTMLElement} View container element
   */
  selectTopBlockInTheView(viewContainer) {
    this.selectionHandler.selectTopBlockInTheView(viewContainer);
  }
  /**
   * Blockify some elements.
   * If container is not initialized, initialize it.
   * Transform some elements to block elements.
   */
  blockify(element, context) {
    if (!this.plugin.settings.enableBlockSelector)
      return;
    if ((import_obsidian9.Platform.isMobile || import_obsidian9.Platform.isMobileApp) && this.plugin.settings.disableBlockSelectorOnMobile) {
      return;
    }
    const container = context == null ? void 0 : context.containerEl;
    if (this.isContainerNotInitialized(container)) {
      this.initializeContainer(container);
    }
    this.elementsToBlocks(element);
  }
  /**
   * Check if container is initialized.
   *
   * @param container {MarkdownPostProcessorContext.containerEl} Container element
   * @returns {boolean} True if container is initialized
   */
  isContainerNotInitialized(container) {
    return container instanceof HTMLElement && !container.hasClass(BLOCK_SELECTOR);
  }
  /**
   * Initialize container.
   * Add some event listeners to container.
   *
   * @param container {MarkdownPostProcessorContext.containerEl} Container element
   */
  initializeContainer(container) {
    container.addClass(BLOCK_SELECTOR);
    container.addEventListener(
      "click",
      (e) => this.selectionHandler.onBlockClick(e)
    );
    container.addEventListener(
      "focusout",
      () => this.selectionHandler.unselect()
    );
    container.addEventListener(
      "keydown",
      (e) => this.selectionHandler.onKeyDown(e)
    );
  }
  /**
   * Set `data-rve-block` attribute to block elements.
   *
   * @param element {HTMLElement} Element to start searching
   */
  elementsToBlocks(element) {
    const elements = element.querySelectorAll(BLOCKS.join(", "));
    elements.forEach((el) => {
      if (el.hasClass(FRONTMATTER))
        return;
      el.setAttribute(BLOCK_ATTR, "true");
      el.setAttribute("tabindex", "-1");
    });
  }
};

// src/main.ts
var ReadingViewEnhancer = class extends import_obsidian10.Plugin {
  /**
   * On load,
   *
   * - Load settings & styles
   * - Activate block selector
   *     - It actually do its work if settings.enableBlockSelector is true
   * - Register all commands
   * - Add settings tab
   */
  async onload() {
    await this.loadSettings();
    this.styles = new RveStyles();
    this.app.workspace.onLayoutReady(() => this.applySettingsToStyles());
    this.blockSelector = new BlockSelector(this);
    this.blockSelector.activate();
    new Commands(this).register();
    this.addSettingTab(new RveSettingTab(this));
    console.log("Loaded 'Reading View Enhancer'");
  }
  /**
   * On unload,
   *
   * - Remove all styles
   */
  async onunload() {
    this.styles.cleanup();
    console.log("Unloaded 'Reading View Enhancer'");
  }
  // ===================================================================
  /**
   * Load settings
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Save settings
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Apply settings to styles
   *
   * - Apply block color
   * - Apply always on collapse indicator
   * - Apply prevent table overflowing
   * - Apply scrollable code
   */
  applySettingsToStyles() {
    this.applyBlockColor();
    this.applyAlwaysOnCollapse();
    this.applyPreventTableOverflowing();
    this.applyScrollableCode();
    this.styles.apply();
  }
  /**
   * Apply block color
   *
   * @param isImmediate {boolean} Whether to apply styles immediately
   */
  applyBlockColor(isImmediate = false) {
    const blockColor = this.styles.of("block-color");
    blockColor.set(this.settings.blockColor);
    if (isImmediate)
      this.styles.apply();
  }
  /**
   * Apply always on collapse indicator
   *
   * @param isImmediate {boolean} Whether to apply styles immediately
   */
  applyAlwaysOnCollapse(isImmediate = false) {
    this.styles.of("collapse-indicator").isActive = this.settings.alwaysOnCollapseIndicator;
    if (isImmediate)
      this.styles.apply();
  }
  /**
   * Apply prevent table overflowing
   *
   * @param isImmediate {boolean} Whether to apply styles immediately
   */
  applyPreventTableOverflowing(isImmediate = false) {
    this.styles.of("prevent-table-overflowing").isActive = this.settings.preventTableOverflowing;
    if (isImmediate)
      this.styles.apply();
  }
  /**
   * Apply scrollable code
   *
   * @param isImmediate {boolean} Whether to apply styles immediately
   */
  applyScrollableCode(isImmediate = false) {
    this.styles.of("scrollable-code").isActive = this.settings.scrollableCode;
    if (isImmediate)
      this.styles.apply();
  }
};
